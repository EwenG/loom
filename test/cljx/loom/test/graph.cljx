(ns cljx.loom.test.graph
  (:require [loom.graph :as g]
            #+clj [clojure.test :as t]
            #+cljs [cemerick.cljs.test :as t])
  #+cljs (:require-macros [cemerick.cljs.test :as tm]))

(tm/deftest simple-graph-test
  (let [g1 (g/graph [1 2] [1 3] [2 3] 4)
        g2 (g/graph {1 [2 3] 2 [3] 4 []})
        g3 (g/graph g1)
        g4 (g/graph g3 (g/digraph [5 6]) [7 8] 9)
        g5 (g/graph)]
    (tm/testing "Construction, nodes, edges"
      (tm/are [expected got] (= expected got)
                          #{1 2 3 4} (set (g/nodes g1))
                          #{[1 2] [2 1] [1 3] [3 1] [2 3] [3 2]} (set (g/edges g1))
                          (set (g/nodes g2)) (set (g/nodes g1))
                          (set (g/edges g2)) (set (g/edges g1))
                          (set (g/nodes g3)) (set (g/nodes g1))
                          (set (g/nodes g3)) (set (g/nodes g1))
                          #{1 2 3 4 5 6 7 8 9} (set (g/nodes g4))
                          #{[1 2] [2 1] [1 3] [3 1] [2 3]
                            [3 2] [5 6] [6 5] [7 8] [8 7]} (set (g/edges g4))
                          #{} (set (g/nodes g5))
                          #{} (set (g/edges g5))
                          true (g/has-node? g1 4)
                          true (g/has-edge? g1 1 2)
                          false (g/has-node? g1 5)
                          false (g/has-edge? g1 4 1)))
    (tm/testing "Successors"
      (tm/are [expected got] (= expected got)
                          #{2 3} (set (g/successors g1 1))
                          #{1 2} (set (g/successors g1 3))
                          #{} (set (g/successors g1 4))
                          2 (g/out-degree g1 1)
                          2 (g/out-degree g1 3)
                          0 (g/out-degree g1 4)))
    (tm/testing "Add & remove"
      (tm/are [expected got] (= expected got)
                          #{1 2 3 4 5} (set (g/nodes (g/add-nodes g1 5)))
                          #{:a :b :c} (set (g/nodes (g/add-nodes g5 :a :b :c)))
                          #{{:id 1} {:id 2}} (set (g/nodes (g/add-nodes g5 {:id 1} {:id 2})))
                          #{[1 2] [2 1]} (set (g/edges (g/add-edges g5 [1 2])))
                          #{1 2} (set (g/nodes (g/remove-nodes g1 3 4)))
                          #{[1 2] [2 1]} (set (g/edges (g/remove-nodes g1 3 4)))
                          #{1 2 3 4} (set (g/nodes (g/remove-edges g1 [1 2] [2 1] [1 3] [3 1])))
                          #{[2 3] [3 2]} (set (g/edges (g/remove-edges
                                                       g1 [1 2] [2 1] [1 3] [3 1])))))))

(tm/deftest simple-digraph-test
  (let [g1 (g/digraph [1 2] [1 3] [2 3] 4)
        g2 (g/digraph {1 [2 3] 2 [3] 4 []})
        g3 (g/digraph g1)
        g4 (g/digraph g3 (g/graph [5 6]) [7 8] 9)
        g5 (g/digraph)
        g6 (g/transpose g1)]
    (tm/testing "Construction, nodes, edges"
      (tm/are [expected got] (= expected got)
                          #{1 2 3 4} (set (g/nodes g1))
                          #{1 2 3 4} (set (g/nodes g6))
                          #{[1 2] [1 3] [2 3]} (set (g/edges g1))
                          #{[2 1] [3 1] [3 2]} (set (g/edges g6))
                          (set (g/nodes g2)) (set (g/nodes g1))
                          (set (g/edges g2)) (set (g/edges g1))
                          (set (g/nodes g3)) (set (g/nodes g1))
                          (set (g/nodes g3)) (set (g/nodes g1))
                          #{1 2 3 4 5 6 7 8 9} (set (g/nodes g4))
                          #{[1 2] [1 3] [2 3] [5 6] [6 5] [7 8]} (set (g/edges g4))
                          #{} (set (g/nodes g5))
                          #{} (set (g/edges g5))
                          true (g/has-node? g1 4)
                          true (g/has-edge? g1 1 2)
                          false (g/has-node? g1 5)
                          false (g/has-edge? g1 2 1)))
    (tm/testing "Successors"
      (tm/are [expected got] (= expected got)
                          #{2 3} (set (g/successors g1 1))
                          #{} (set (g/successors g1 3))
                          #{} (set (g/successors g1 4))
                          2 (g/out-degree g1 1)
                          0 (g/out-degree g1 3)
                          0 (g/out-degree g1 4)
                          #{1 2} (set (g/predecessors g1 3))
                          #{} (set (g/predecessors g1 1))
                          2 (g/in-degree g1 3)
                          0 (g/in-degree g1 1)
                          #{1 2} (set (g/successors g6 3))
                          #{} (set (g/successors g6 1))
                          2 (g/out-degree g6 3)
                          0 (g/out-degree g6 1)))
    (tm/testing "Add & remove"
      (tm/are [expected got] (= expected got)
                          #{1 2 3 4 5} (set (g/nodes (g/add-nodes g1 5)))
                          #{:a :b :c} (set (g/nodes (g/add-nodes g5 :a :b :c)))
                          #{{:id 1} {:id 2}} (set (g/nodes (g/add-nodes g5 {:id 1} {:id 2})))
                          #{[1 2]} (set (g/edges (g/add-edges g5 [1 2])))
                          #{1 2} (set (g/nodes (g/remove-nodes g1 3 4)))
                          #{[1 2]} (set (g/edges (g/remove-nodes g1 3 4)))
                          #{1 2 3 4} (set (g/nodes (g/remove-edges g1 [1 2] [1 3])))
                          #{[2 3]} (set (g/edges (g/remove-edges g1 [1 2] [1 3])))))))

(tm/deftest simple-weighted-graph-test
  (let [g1 (g/weighted-graph [1 2 77] [1 3 88] [2 3 99] 4)
        g2 (g/weighted-graph {1 {2 77 3 88} 2 {3 99} 4 []})
        g3 (g/weighted-graph g1)
        g4 (g/weighted-graph g3 (g/weighted-digraph [5 6 88]) [7 8] 9)
        g5 (g/weighted-graph)]
    (tm/testing "Construction, nodes, edges"
      (tm/are [expected got] (= expected got)
                          #{1 2 3 4} (set (g/nodes g1))
                          #{[1 2] [2 1] [1 3] [3 1] [2 3] [3 2]} (set (g/edges g1))
                          (set (g/nodes g2)) (set (g/nodes g1))
                          (set (g/edges g2)) (set (g/edges g1))
                          (set (g/nodes g3)) (set (g/nodes g1))
                          (set (g/nodes g3)) (set (g/nodes g1))
                          #{1 2 3 4 5 6 7 8 9} (set (g/nodes g4))
                          #{[1 2] [2 1] [1 3] [3 1] [2 3]
                            [3 2] [5 6] [6 5] [7 8] [8 7]} (set (g/edges g4))
                          #{} (set (g/nodes g5))
                          #{} (set (g/edges g5))
                          true (g/has-node? g1 4)
                          true (g/has-edge? g1 1 2)
                          false (g/has-node? g1 5)
                          false (g/has-edge? g1 4 1)))
    (tm/testing "Successors"
      (tm/are [expected got] (= expected got)
                          #{2 3} (set (g/successors g1 1))
                          #{1 2} (set (g/successors g1 3))
                          #{} (set (g/successors g1 4))
                          2 (g/out-degree g1 1)
                          2 (g/out-degree g1 3)
                          0 (g/out-degree g1 4)))
    (tm/testing "Add & remove"
      (tm/are [expected got] (= expected got)
                          #{1 2 3 4 5} (set (g/nodes (g/add-nodes g1 5)))
                          #{:a :b :c} (set (g/nodes (g/add-nodes g5 :a :b :c)))
                          #{{:id 1} {:id 2}} (set (g/nodes (g/add-nodes g5 {:id 1} {:id 2})))
                          #{[1 2] [2 1]} (set (g/edges (g/add-edges g5 [1 2])))
                          #{1 2} (set (g/nodes (g/remove-nodes g1 3 4)))
                          #{[1 2] [2 1]} (set (g/edges (g/remove-nodes g1 3 4)))
                          #{1 2 3 4} (set (g/nodes (g/remove-edges g1 [1 2] [2 1] [1 3] [3 1])))
                          #{[2 3] [3 2]} (set (g/edges (g/remove-edges
                                                       g1 [1 2] [2 1] [1 3] [3 1])))))
    (tm/testing "Weight"
      (tm/are [expected got] (= expected got)
                          77 (g/weight g1 1 2)
                          77 (g/weight g2 1 2)
                          77 (g/weight g3 1 2)
                          88 (g/weight g4 6 5)
                          1 (g/weight g4 7 8)))))

(tm/deftest simple-weighted-digraph-test
  (let [g1 (g/weighted-digraph [1 2 77] [1 3 88] [2 3 99] 4)
        g2 (g/weighted-digraph {1 {2 77 3 88} 2 {3 99} 4 []})
        g3 (g/weighted-digraph g1)
        g4 (g/weighted-digraph g3 (g/weighted-graph [5 6 88]) [7 8] 9)
        g5 (g/weighted-digraph)
        g6 (g/transpose g1)]
    (tm/testing "Construction, nodes, edges"
      (tm/are [expected got] (= expected got)
                          #{1 2 3 4} (set (g/nodes g1))
                          #{1 2 3 4} (set (g/nodes g6))
                          #{[1 2] [1 3] [2 3]} (set (g/edges g1))
                          #{[2 1] [3 1] [3 2]} (set (g/edges g6))
                          (set (g/nodes g2)) (set (g/nodes g1))
                          (set (g/edges g2)) (set (g/edges g1))
                          (set (g/nodes g3)) (set (g/nodes g1))
                          (set (g/nodes g3)) (set (g/nodes g1))
                          #{1 2 3 4 5 6 7 8 9} (set (g/nodes g4))
                          #{[1 2] [1 3] [2 3] [5 6] [6 5] [7 8]} (set (g/edges g4))
                          #{} (set (g/nodes g5))
                          #{} (set (g/edges g5))
                          true (g/has-node? g1 4)
                          true (g/has-edge? g1 1 2)
                          false (g/has-node? g1 5)
                          false (g/has-edge? g1 2 1)))
    (tm/testing "Successors"
      (tm/are [expected got] (= expected got)
                          #{2 3} (set (g/successors g1 1))
                          #{} (set (g/successors g1 3))
                          #{} (set (g/successors g1 4))
                          2 (g/out-degree g1 1)
                          0 (g/out-degree g1 3)
                          0 (g/out-degree g1 4)
                          #{1 2} (set (g/predecessors g1 3))
                          #{} (set (g/predecessors g1 1))
                          2 (g/in-degree g1 3)
                          0 (g/in-degree g1 1)
                          #{1 2} (set (g/successors g6 3))
                          #{} (set (g/successors g6 1))
                          2 (g/out-degree g6 3)
                          0 (g/out-degree g6 1)))
    (tm/testing "Add & remove"
      (tm/are [expected got] (= expected got)
                          #{1 2 3 4 5} (set (g/nodes (g/add-nodes g1 5)))
                          #{:a :b :c} (set (g/nodes (g/add-nodes g5 :a :b :c)))
                          #{{:id 1} {:id 2}} (set (g/nodes (g/add-nodes g5 {:id 1} {:id 2})))
                          #{[1 2]} (set (g/edges (g/add-edges g5 [1 2])))
                          #{1 2} (set (g/nodes (g/remove-nodes g1 3 4)))
                          #{[1 2]} (set (g/edges (g/remove-nodes g1 3 4)))
                          #{1 2 3 4} (set (g/nodes (g/remove-edges g1 [1 2] [1 3])))
                          #{[2 3]} (set (g/edges (g/remove-edges g1 [1 2] [1 3])))))
    (tm/testing "Weight"
      (tm/are [expected got] (= expected got)
                          77 (g/weight g1 1 2)
                          77 (g/weight g2 1 2)
                          77 (g/weight g3 1 2)
                          77 (g/weight g6 2 1)
                          88 (g/weight g4 6 5)
                          1 (g/weight g4 7 8)))))

(tm/deftest fly-graph-test
  (let [fg1 (g/fly-graph :nodes [1 2 3]
                       :successors #(if (= 3 %) [1] [(inc %)])
                       :weight (constantly 88))
        fg2 (g/fly-graph :successors #(if (= 3 %) [1] [(inc %)])
                       :start 1)]
    (tm/testing "Construction, nodes, edges"
      (tm/are [expected got] (= expected got)
                          #{1 2 3} (set (g/nodes fg1))
                          #{1 2 3} (set (g/nodes fg2))
                          #{[1 2] [2 3] [3 1]} (set (g/edges fg1))
                          #{[1 2] [2 3] [3 1]} (set (g/edges fg2))
                          88 (g/weight fg1 1 2)))
    ;; TODO: finish
    ))



(tm/deftest utilities-test
  (tm/testing "Predicates"
    (tm/are [expected got] (= expected got)
                        true (every? true? (map g/graph? [(g/graph [1 2])
                                                        (g/digraph [1 2])
                                                        (g/weighted-graph [1 2])
                                                        (g/weighted-digraph [1 2])
                                                        (g/fly-graph :successors [1 2])
                                                        (reify g/Graph)]))
                        true (every? true? (map g/directed? [(g/digraph [1 2])
                                                           (g/weighted-digraph [1 2])
                                                           (g/fly-graph :predecessors [1 2])
                                                           (reify g/Digraph)]))
                        true (every? true? (map g/weighted? [(g/weighted-graph [1 2])
                                                           (g/weighted-digraph [1 2])
                                                           (g/fly-graph :weight (constantly 1))
                                                           (reify g/WeightedGraph)]))))
  (tm/testing "Adders"
    (let [g (g/weighted-digraph [1 2] [2 3] [3 1])
          sg (g/subgraph g [1 2])
          pg (g/add-path (g/digraph) 1 2 3 4 5)
          cg (g/add-cycle (g/digraph) 1 2 3)]
      (tm/are [expected got] (= expected got)
                          #{1 2} (set (g/nodes sg))
                          #{[1 2]} (set (g/edges sg))
                          true (g/graph? sg)
                          true (g/directed? sg)
                          true (g/weighted? sg)
                          #{[1 2] [2 3] [3 4] [4 5]} (set (g/edges pg))
                          #{[1 2] [2 3] [3 1]} (set (g/edges cg))))))

(comment
  (t/test-ns 'cljx.loom.test.graph)
  )
